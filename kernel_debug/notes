KBUILD_FLAGS += -g
KBUILD_ALAGS += -gdwarf-2
KBUILD_FLAGS += -pg

arm-linux-objdump -S -D a.o 


kernel trace articles
http://www.cnblogs.com/leaven/archive/2011/12/22/2298352.html
http://blog.csdn.net/sandflee/article/details/5751844

/proc/sysrq-trigger该文件能做些什么事情呢？
# 立即重新启动计算机 （Reboots the kernel without first unmounting file systems or syncing disks attached to the system）
echo "b" > /proc/sysrq-trigger
# 立即关闭计算机（shuts off the system）
echo "o" > /proc/sysrq-trigger
# 导出内存分配的信息 （可以用/var/log/message 查看）（Outputs memory statistics to the console）
echo "m" > /proc/sysrq-trigger
# 导出当前CPU寄存器信息和标志位的信息（Outputs all flags and registers to the console）
echo "p" > /proc/sysrq-trigger
# 导出线程状态信息 （Outputs a list of processes to the console）
echo "t" > /proc/sysrq-trigger







画图
http://blog.csdn.net/unbutun/article/details/2828786
# 故意让系统崩溃 （ Crashes the system without first unmounting file systems or syncing disks attached to the system）
echo "c" > /proc/sysrq-trigger
# 立即重新挂载所有的文件系统 （Attempts to sync disks attached to the system）
echo "s" > /proc/sysrq-trigger
# 立即重新挂载所有的文件系统为只读 （Attempts to unmount and remount all file systems as read-only）
echo "u" > /proc/sysrq-trigger
呵呵，此外还有两个，类似于强制注销的功能
e — Kills all processes except init using SIGTERM
i — Kills all processes except init using SIGKILL

内核的调试以及PANIC问题
http://linux.ctocio.com.cn/484/12168484.shtml




使用GDB调试
arm-linux-gnueabi-objdump -D vmlinux > kernel_dump.txt
(gdb) list *(local_bh_enable_ip+0x98)



如何利用API打出所有的STACK出来。
http://www.kgdb.info/linuxdev/backtrace_without_gdb/


linux docs
http://man.chinaunix.net/tech/lyceum/linuxK/tlk.html

gprof
http://en.wikipedia.org/wiki/Gprof


CONFIG_GPROF 

gprof介绍
gprof是GNU profiler工具。可以显示程序运行的“flat profile”，包括每个函数的调用次数，每个函数消耗的处理器时间。也可以显示“调用图”，包括函数的调用关系，每个函数调用花费了多少时间。还可以显示“注释的源代码”，是程序源代码的一个复本，标记有程序中每行代码的执行次数。

为gprof编译程序
在编译或链接源程序的时候在编译器的命令行参数中加入“-pg”选项，编译时编译器会自动在目标代码中插入用于性能测试的代码片断，这些代码在程序在运行时采集并记录函数的调用关系和调用次数，以及采集并记录函数自身执行时间和子函数的调用时间，程序运行结束后，会在程序退出的路径下生成一个gmon.out文件。这个文件就是记录并保存下来的监控数据。可以通过命令行方式的gprof或图形化的Kprof来解读这些数据并对程序的性能进行分析。另外，如果想查看库函数的profiling，需要在编译是再加入“-lc_p”编译参数代替“-lc”编译参数，这样程序会链接libc_p.a库，才可以产生库函数的profiling信息。如果想执行一行一行的profiling，还需要加入“-g”编译参数。


